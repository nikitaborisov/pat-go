package pat

import (
	"crypto/rand"
	"fmt"

	"github.com/cloudflare/circl/group"
	"golang.org/x/crypto/cryptobyte"
)

// Linear-style DLEQ ZKPoK proofs, showing that:
// ( A_i ) = ( x_j ) ( B_{i,j} )
// A_i and B_{i,j} are public group elements
// x_j are secret scalars that you prove knowledge of

type DLEQProof struct {
	// one commitment per equation
	Commitments []group.Element
	// challenge, generated by Fiat-Shamir
	Challenge group.Scalar
	// one response per secret variable
	Responses []group.Scalar
}

func (p DLEQProof) MarshalCompact() ([] byte, error) {
	b := cryptobyte.NewBuilder(nil)
	cEnc, err := p.Challenge.MarshalBinary()
	if err != nil {
		return nil, err
	}
	b.AddBytes(cEnc)

	b.AddUint16(uint16(len(p.Responses)))
	for _, ri := range p.Responses {
		riEnc, err := ri.MarshalBinary()
		if err != nil {
			return nil, err
		}
		b.AddBytes(riEnc)
	}
	return b.Bytes()
}

func UnmarshalProofCompact(encodedProof [] byte, g group.Group) (DLEQProof, error) {
	scalarLen := g.Params().ScalarLength
	input := cryptobyte.String(encodedProof)

	challengeEnc := make([]byte, scalarLen)

	if !input.ReadBytes(&challengeEnc, int(scalarLen)) {
		return DLEQProof{}, fmt.Errorf("cannot read challenge")
	}

	challenge := g.NewScalar()
	err := challenge.UnmarshalBinary(challengeEnc)
	if err != nil {
		return DLEQProof{}, err
	}

	var responseLen uint16

	if !input.ReadUint16(&responseLen) {
		return DLEQProof{}, fmt.Errorf("error reading response length")
	}

	responses := make([] group.Scalar, responseLen)

	for i := range responses {
		responseEnc := make([]byte, scalarLen)
		if !input.ReadBytes(&responseEnc, int(scalarLen)) {
			return DLEQProof{}, fmt.Errorf("error reading response %d", i)
		}
		responses[i] = g.NewScalar()
		err := responses[i].UnmarshalBinary(responseEnc)
		if err != nil {
			return DLEQProof{}, err
		}
	}

	if !input.Empty() {
		return DLEQProof{}, fmt.Errorf("unparsed bytes leftover")
	}

	return DLEQProof {
		Challenge: challenge,
		Responses: responses,
	}, nil
}

// XXX: eliminate the last parameter when upgrading to the latest version of circl/group that has a .Group() method
func scalarVectorElementMatrixMul(x []group.Scalar, B [][]group.Element, g group.Group) []group.Element {
	result := make([]group.Element, len(B))
	for i, Bi := range B {
		result[i] = g.Identity()
		for j, Bij := range Bi {
			if Bij != nil {
				t := g.NewElement()
				t.Mul(Bij, x[j])
				result[i].Add(result[i], t)
			}
		}
	}
	return result
}

func VerifyProofParams(A []group.Element, B [][]group.Element, x []group.Scalar, g group.Group) error {
	if len(A) != len(B) {
		return fmt.Errorf("A (len %d) and B (len %d) must have the same length", len(A), len(B))
	}

	for i, v := range B {
		if len(v) != len(x) {
			return fmt.Errorf("B[%d] (len %d) must have the same length as x (len %d)", i, len(v), len(x))
		}
	}

	r := scalarVectorElementMatrixMul(x, B, g)
	for i, ri := range r {
		if !A[i].IsEqual(ri) {
			return fmt.Errorf("row %d not equal", i)
		}
	}

	return nil
}

func computeChallenge(A []group.Element, B [][]group.Element, commitments []group.Element, g group.Group, 
	dst []byte) (group.Scalar, error) {
	b := cryptobyte.NewBuilder(nil)

	for _, Ai := range A {
		Aienc, err := Ai.MarshalBinary()
		if err != nil {
			return nil, err
		}
		b.AddBytes(Aienc)
	}

	zeroEnc, err := g.Identity().MarshalBinary()
	if err != nil {
		return nil, err
	}

	for _, Bi := range B {
		for _, Bij := range Bi {
			if Bij == nil {
				b.AddBytes(zeroEnc)
			} else {
				Bijenc, err := Bij.MarshalBinary()
				if err != nil {
					return nil, err
				}
				b.AddBytes(Bijenc)
			}
		}
	}

	for _, Ci := range commitments {
		Cienc, err := Ci.MarshalBinary()
		if err != nil {
			return nil, err
		}
		b.AddBytes(Cienc)
	}

	hashInput, err := b.Bytes()
	if err != nil {
		return nil, err
	}

	return g.HashToScalar(hashInput, dst), nil
}

func ComputeProof(A []group.Element, B [][]group.Element, x []group.Scalar, g group.Group,
	dst []byte) (DLEQProof, error) {
	// step one: generate random scalars for each secret variable

	alpha := make([]group.Scalar, len(x))

	for i := range x {
		alpha[i] = g.RandomScalar(rand.Reader)
	}

	commitments := scalarVectorElementMatrixMul(alpha, B, g)

	challenge, err := computeChallenge(A, B, commitments, g, dst)
	if err != nil {
		return DLEQProof{}, err
	}

	responses := make([]group.Scalar, len(x))

	for i, xi := range x {
		responses[i] = g.NewScalar()
		responses[i].Mul(challenge, xi)
		responses[i].Add(responses[i], alpha[i])
	}

	return DLEQProof{
		Commitments: commitments,
		Challenge:   challenge,
		Responses:   responses,
	}, nil
}

// ignores p.Commitments and instead recomputes them from the responses, and verifies challenge equality
func VerifyProofCompact(p DLEQProof, A []group.Element, B [][]group.Element, g group.Group, dst []byte) (bool, error) {
	values := scalarVectorElementMatrixMul(p.Responses, B, g)

	commitments := make([]group.Element, len(B))
	for i, Ai := range A {
		// commitmets[i] = values / Ai^c
		t := g.NewElement()
		t.Mul(Ai, p.Challenge)
		t.Neg(t)
		commitments[i] = g.NewElement()
		commitments[i].Add(values[i], t)
	}

	challenge, err := computeChallenge(A, B, commitments, g, dst)
	if err != nil {
		return false, err
	}

	if challenge.IsEqual(p.Challenge) {
		return true, nil
	} else {
		return false, fmt.Errorf("challenge computation failed")
	}
}
